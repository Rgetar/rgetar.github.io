<!DOCTYPE html>
<html xmlns = "http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<title>Ordinal Explorer Online</title>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<style type="text/css" media="Screen">
a{text-decoration:none;color:blue;}
a:hover{text-decoration:underline;}
a:visited{color:blue;}
li{list-style-type:none;cursor:pointer;padding-left: 7px;padding-right: 27px; min-height:32px;}
//li{list-style-type:none;cursor:pointer;padding-left: 7px;outline: 1px solid black}
//ul{margin-right:auto;widthq:100%}
td{cursor:pointer;}
sub{font-size:0.83rem;}
sup{font-size:0.83rem;}
//ul{display:flex;flex-direction:column-reverse;}
</style>
<body style="font-family:Arial;white-space:pre;line-height:0;"
><span onmousedown="return false" id="sidebar" style="line-height:2;position:absolute;right:0px;width:215px;padding-left:42px;top:0;bottom:0;overflow:auto;float:right;background:#f5fdff;line-height:1.5;"
hidden>
<b style="font-size:16px;">Ordinal Explorer Online</b>
<div id="reset" style="
background:#ffffd0;
margin-top:10px;
min-width:180px;
min-height:21px;
text-align:center;
float:left;
outline:1px solid #909090;
border-radius:5px;
line-height:1.5;
opacity:0.4;
font-size:14px;
cursor:pointer;
">Reset list</div
><div id="uncreset" style="
background:#d0d0ff;
margin-top:7px;
margin-bottom:10px;
min-width:180px;
min-height:21px;
text-align:center;
float:left;
outline:1px solid #909090;
border-radius:5px;
line-height: 21px;
font-size:12px;
cursor:pointer;
">Change mode</div
>



<div style="
float:left;
min-height:16px;
min-width:12px;
"></div><div id="decef" style="
float:left;
outline:1px solid #909090;
border-radius:5px 0 0 5px;
min-height:16px;
line-height:16px;
text-align:center;
padding:3px 5px;
font-size:25px;
background:#ffffd0;
opacity:0.4;
cursor:default;
">◅</div><div id="ecfv" style="
float:left;
outlinea:1px solid #909090;
min-width:65px;
max-width:65px;
min-height:16px;
margin-left:1px;
padding:0 20px;
font-size:11px;
line-height:1;
backgrounda:#ffffff;
cursor:pointer;
">strings per<br/>expansion: 1</div><div id="incef" style="
float:left;
outline:1px solid #909090;
min-height:16px;
line-height:16px;
border-radius:0 5px 5px 0;
margin-left:1px;
padding:3px 5px;
font-size:25px;
background:#d0ffd0;
cursor:pointer;
">▻</div>

<div align="left" style="font-size:13px;padding:5px;"><i>Format of ordinals:</i>
<table id="switchformat" border="3" cellpadding="3" style="background:#ffffff;border-spacing:0;">
<tr style="font-size:12px;line-height:1.4;">
<td id="for2">[[c]][[[c]][]]</td>
<td id="for0">ω<sup>ε<sub>0</sub> + 1</sup></td>
<td id="for1" style="font-size:15px;"> ε<sub>0</sub>ω </td>
</tr>
</table></div>

<div align="left" style="font-size:13px;line-height:1.05;margin-left:-16px;margin-top:-23px;"><table cellpadding="0" style="float:left;border-spacing:0;">
<tr>
<td id="decdec" style="color:#eeeeee;font-size:25px;cursor:default;">◅ </td>
<td id="decintoboosterslp" style="cursor:default;line-height:2;"><table border="3" cellpadding="0" style="float:left;border-spacing:0;">
<tr>
<td id="decintoboostersl" style="font-size:15px;cursor:default;background:#ffffff;"></td>
</tr>
</table></td>
<td id="incdec" style="font-size:25px;"> ▻</td>
</tr>
</table><i><sub style="font-size:11px;">   levels of decomposition<br/>   into boosters</sub></i></div>
<div id="switchindentmode" align="left" style="font-size:13px;"><i>Indentation mode:</i>
<div id="indentmode2" style="
float:left;
outline:1px solid #909090;
border-radius:5px 0 0 5px;
min-width:30px;
min-height:34px;
text-align:center;
padding:3px 5px;
font-size:12px;
line-height:34px;
background:#ffffff;
cursor:pointer;
">NO</div><div id="indentmode1" style="
float:left;
outline:1px solid #909090;
min-width:40px;
min-height:34px;
margin-left:1px;
padding:3px 5px;
font-size:11px;
line-height:1;
background:#ffffff;
cursor:pointer;
">fundamental<br/>sequence<br/>alignment</div><div id="indentmode0" style="
float:left;
outline:1px solid #909090;
min-width:40px;
min-height:34px;
border-radius:0 5px 5px 0;
margin-left:1px;
padding:3px 5px;
font-size:11px;
line-height:1;
background:#ffffff;
cursor:pointer;
">recursive<br/>expansion<br/>alignment</div></div>



<div align="left" style="font-size:13px;line-height:1.65;margin-left:-16px;margin-top:-23px"><table cellpadding="0" style="float:left;border-spacing:0;">
<tr>
<td id="decd" style="font-size:25px;">◅ </td>
<td id="disp" style="cursor:default;line-height:2;"><table border="3" cellpadding="0" style="float:left;border-spacing:0;">
<tr>
<td id="dis" style="font-size:15px;cursor:default;background:#d0ffd0"></td>
</tr>
</table></td>
<td id="incd" style="font-size:25px;"> ▻</td>
</tr>
</table><i style="line-height:40px;font-size:11px">  displayed fs elements</i></div>
<div id="vtext" style="
background:#d0ffd0;
margin-top:7px;
margin-bottom:10px;
min-width:180px;
min-height:21px;
text-align:center;
float:left;
outline:1px solid #909090;
border-radius:5px;
line-height: 21px;
font-size:12px;
cursor:pointer;
">text near mouse cursor</div
>

<span style="font-size:12px">last updated: 10 January 2023</span>
<a id="oldversionlink" style="font-size:12px" href="Ordinal Explorer (versions).htm">old versions and other projects</a>
</span><span id="listc" style="float:left;line-height:2;position: absolute;heighta:80%;top:0;bottom:0;padding-bottom:32px;left:0;right:0;overflow-x:overlay;overflow-y:auto;display:flex;flex-direction:column-reverse;" onmousedown="return false"><div><div
 id="mulmark" align="center" style="position:absolute;min-width:20px;min-height:20px;max-width:20px;max-height:20px;font-size:20px;line-height:0.7;border:1px solid #909090;border-radius:8px;padding:0;background:#d0d0ff;cursor:pointer;" hidden>↑</div><div
 id="expmark_" align="center" style="position:absolute;min-width:20px;min-height:20px;max-width:20px;max-height:20px;font-size:28px;line-height:0.7;border:1px solid #909090;border-radius:8px;padding:0;background:#d0ffd0;cursor:pointer;" hidden>+</div><div
 id="expmark" align="center" style="position:absolute;min-width:20px;min-height:20px;max-width:20px;max-height:20px;font-size:28px;line-height:0.7;border:1px solid #909090;border-radius:8px;padding:0;margina-left:-15px;background:#d0ffd0;cursor:pointer;letter-spacing:-6px;" hidden>+<sup style="font-size:11px;vertical-align:11px">+</sup>    </div><div
 id="smexmark" align="center" style="position:absolute;min-width:20px;min-height:20px;max-width:20px;max-height:20px;font-size:16px;line-height:1.2;border:1px solid #909090;border-radius:8px;padding:0;background:#e0ffff;cursor:pointer;" hidden>+</div><div
 id="colmark" align="center" style="position:absolute;min-width:20px;min-height:20px;max-width:20px;max-height:20px;font-size:28px;line-height:0.57;border:1px solid #909090;border-radius:8px;padding:0;background:#fff0b0;cursor:pointer;" hidden>-</div><ul style="padding-left:104px;float:left;min-width:calc(100% - 104px);" id="list"
></ul></span><span id="vsidebars" onmousedown="return false" style="background:#e0ffe0;line-height:0.5;position: fixed;right:17px;top:0;float:right;font-size:25px"><table>
<tr>
<td id="vsidebar">«</td>
</tr>
</table></span><span id="counter" onmousedown="return false" style="position:fixed;right:30px;bottom:14px;float:right;font-size:12px;cursor:default"
>Counter: 1</span><div id="xs" style="position:fixed;border:1px solid #cccccc;border-radius:5px;padding:5px 15px 5px 15px;"
hidden><script
>'use strict'

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

window.addEventListener("keydown", function(e) {
   if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
      e.preventDefault();
   }
}, false);

function mod(n,m)
{
return (n%m+m)%m;
}

// get position of last symbol '[' of string st
function getls(st){
let e=st.length;
let np=0;
while((e>-1)&&(np!=0||st[e]!='[')){
   e--;
   if (st[e]=='[') np--;
   else if (st[e]=='!') np++;}
return e;}

// get position of first symbol '!' of string st (if l==true then first)
function getfs(st){
let e=-1;
let np=0;
while((e<st.length)&&(np!=0||st[e]!='!')){
   e++;
   if (st[e]=='[') np--;
   else if (st[e]=='!') np++;}
return e;}

// create base]booster[ string
function bb(base,booster){
return base+'['+booster+'!';}

// get base of string st
function base(st){
return st.slice(0,getls(st));}

// get booster of string st
function booster(st){
return st.slice(getls(st)+1,-1);}

// get predecessor of successor ordinal st = X + 1
function pred(st){
return st.slice(0,-2);}

// compare expressions st1, st2 (if st1<st2 then -1; if st1==st2 then 0; if st1>st2 then 1)
//function compare(st1,st2,b=false){
function compare(st1,st2){
return st1.localeCompare(st2);}

function ocd(st){
let n=0;
for(let s of st)
   {if(s=='[')
      {n++}
   else if(s=='!')
      {n--}	
   }
return n;
}

function getpos(st)
{
let n=0;
let pcar=[];
let l=st.length;
let l2=2*l;
st=st+st;
let e=0;
while(e<l2)
   {
   if(pcar.length)
      {
      if(st[e]=='[')
         {
         n++;
         if(n==2)
            {
            pcar.push(e);
            n=1;
            }
         }
      else if(st[e]=='!')
         {
         n--;
         if(n<=0)
            {
            pcar.pop();
            n++;
            }
         }
      }
   else
      {
      if(st[e]=='[')
         {
         pcar.push(e);
         n=1;
         }
      }
   e++;
   }
e=0;
while(pcar.length>2&&pcar.at(-2)>=l)
    pcar.pop();
let m=pcar.at(-1)-l;
while(pcar[e]<m)
   e++;
m=pcar.length-1;
if(e+1==m)
   return pcar[e];
   
let psar=[];
for(let i=e;i<m;i++)
   psar.push(st.slice(pcar[i],pcar[i+1]));
let b=true;
for(let i=e+1;i<m;i++)
   if(psar[i]!=psar[e])
      b=false;
if(b)
   return pcar[e];
for(let i=e+1;i<m;i++)
   {
   let i1=i;
   let e1=e;
   while(psar[i1]==psar[e1])
      {
      i1--;
      e1--;
      if(i1<e)
         i1=pcar.length-1;
      if(e1<e)
         e1=pcar.length-1;
      }
   if(psar[i1]>psar[e1])
      {
      e=i;
      }
   }
return pcar[e+1]%l;
}

function overperiod(st){
if(st[0]!=col)
   return st;
let i=0;
for(let e=1;e<st.length;e++)
   if(st.slice(0,e)==st.slice(-e))
      i=e;
return i?st.slice(0,-i):st;
}

function overprimer(st,st0){
if(st[0]!=col)
   return st0;
let i=0;
for(let e=1;e<st.length;e++)
   if(st.slice(0,e)==st0.slice(-e))
      i=e;
return i?st0.slice(0,-i):st0;
}

function setfsarrays()
{
fsnumber=1;
fsopeningarray=[fsopening];
fsperiodarray=[fsperiod0];
fsendingarray=[fsending];
let i=fsending.length;
let u=fsperiod1.length;
let j=fsperiod0.length;
let y=fsopening.length;
let q=j-1;
while(fsperiod0[q]=='!')
   q--;
let b=true;
for(let e=1;e<=q;e++)
   {
   let a=fsperiod0[e-1];
   if(a=='[')
      i++;
   else if(a=='!')
      i--;
   if(fsperiod0[e]!='!')
      {
      fsopeningarray.push(fsopening+fsperiod0.slice(0,e));
      if(!b)
         fsopeningarray[fsnumber]=fsopeningarray[fsnumber].slice(0,-j);
      fsperiodarray.push(fsperiod0.slice(e)+fsperiod0.slice(0,e));
      if(b&&y+e>=j&&fsopeningarray[fsnumber].slice(-j)==fsperiodarray[fsnumber])
         {
         fsopeningarray[fsnumber]=fsopeningarray[fsnumber].slice(0,-j);
         i-=u;
         b=false;
         }
      fsendingarray.push('!'.repeat(i));
      if(fsperiod0[e]==col)
         {
         fsopeningarray.push(fsopeningarray[fsnumber]);
         fsperiodarray.push(fsperiodarray[fsnumber]);
         fsendingarray.push('[!'+fsendingarray[fsnumber]);
         fsnumber++;
         }
      fsnumber++;
      }
   }
}

// left non-empty base
function leftbase(st)
{
let beta=base(st);
return beta?leftbase(beta):st;
}

// if st is not epsilon: -1
// epsilon: 0
// Omega: 1
// L: 2
// R: 3
// ...
function getepslevel(st)
{
if(st==bo)
   return 0;
if(!st)
   return -1;
if(st==col)
   return nlevels;
let x=booster(st);
if(st>x)
   return -1;
return getepslevel(leftbase(x))-1;
}

function flooreps(st,n)
{
if(!st||getepslevel(st)>=n)
   return st;
return flooreps(base(st),n);
}

// n = 0: least epsilon above st
// n = 1: least Omega above st
// n = 2: least L above L st
//...
function nexteps(st,n)
{
if(st>=col||n>nlevels)
   return 'd';
if(n==nlevels)
   return col;
return bb(flooreps(st,n),nexteps(st,n+1));
}

function card(st)
{
if(st==col)
if(nlevels)
   {
   cardclass=2;
   return col;
   }
else
   {
   cardclass=1;
   return '[[!!';
   }
if(st==bo)
   {
   if(nlevels&&uncountablemode)
      {
      cardclass=2;
      return col;
      }
   else
      {
      cardclass=1;
      return '[[!!';
      }
   }
if(st<'[[!!')
   {
   cardclass=0;
   return st;
   }
if(st<leastuncounable)
   {
   cardclass=1;
   return '[[!!';
   }

cardclass=2;
while(st.length>1&&st>booster(st))
   st=base(st);
return st;
}

// card, but if < Ω, returns empty string
function ecard(st)
{
let c=card(st);
if(c<leastuncounable)
   return '';
return st;
}

// get n-th element of fs of ordinal st
function fs(st,n,nn=0){

// optimization
if(st==fscurrent)
   //return fsopening+(fsperiod0.repeat(nn))+(fsperiod1.repeat(nn)+fsending);
   return fsopeningarray[subperiodpositionshift]+(fsperiodarray[subperiodpositionshift].repeat(nn))+(fsperiod1.repeat(nn)+fsendingarray[subperiodpositionshift]);

if(fscurrent)
   subperiodpositionshift=0;

fscurrent=st;

// limit rule
if(st==bo)
   {
   cofcurrent='[[!!';
   cofclass=0;
   
   if(uncountablemode)
      {
      //uncountable
      fsopening=col;
      fsperiod0='['+col;
      fsperiod1='!';
      fsending='';
      setfsarrays();
      return fsopening+fsperiod0.repeat(nn)+fsperiod1.repeat(nn)+fsending;
      }
   else
      {
      //countable
   	fsopening=nlevels?'['.repeat(nlevels-1):col;
      fsperiod0='['+col;
      fsperiod1='!';
      fsending=nlevels?'!'.repeat(nlevels-1):'';
      setfsarrays();
      return fsopening+fsperiod0.repeat(nn)+fsperiod1.repeat(nn)+fsending;
      }
   }

let i=st.length-1;
while(st[i]=='!')
   i--;
let e=st[i]=='[';
let st0=st.slice(0,i);
let st1=st.slice(i+(e?2:1));
let s1;

// successor and plain rule
if(e)
   {
   st0+='!';
   cofcurrent=st1?'[[!!':'[!';
   cofclass=st1?st==cofcurrent?3:0:2;
   let st2=st1;
   st1=st1.slice(1);
   s1=bb('',booster(st0));
   fsopening=base(st0);
   fsperiod0=s1;
   fsperiod1='';
   fsending=st1;
   setfsarrays();
   return fsopening+fsperiod0.repeat(nn)+fsending;
   }

// main rule
let stt=st0;
let u=i-1;

while(st0[u]=='[')
  u--;
u=i-u-1;

st0+='[';

st1=st1.slice(u);
let s;

u++;
let uo='['.repeat(u);

let cb=[st];
//let nc=[1,1];
while(cb.at(-1).length>1)
   {cb.push(booster(cb.at(-1)));
   }

let pn=cb.length-1;
let lrn=pn;
let nl=nlevels;
let lr='c';
let lar=[pn];
//let r;           // more powerful system
while(nl)
   {if(cb[pn]<lr)
      {
      //lrn=pn;
      lr=cb[pn];
      lar.push(pn);
      nl--;
      
      // more powerful system
      /*let q=base(lr);
      if(lar.length>2&&q!=r)
         {
         nl=0;
         r=q;
         while(q.length>1&&booster(q)==col)
            {
            q=base(q);
            nl++;
            }
         }*/
      
      }
   else
      {
      pn--;
      
      // uncountable
      if(pn<0)
         {
         fsopening=st0.slice(0,-1);
         fsperiod0='['+col;
         while(fsopening.slice(-2)==fsperiod0)
            fsopening=fsopening.slice(0,-2);
         fsperiod1='!';
         fsending='!'.repeat(ocd(fsopening));
         cofcurrent=lr;
         cofclass=st==cofcurrent?3:0;
         setfsarrays();
         return fsopening+fsperiod0.repeat(nn)+fsperiod1.repeat(nn)+fsending;
         }
      
      }
   }

let prover=Array(cb.length);

// cb: [[[Xc]]] → X[
for(i=pn;i<cb.length;i++)
   {while(cb[i][0]=='[')
      {cb[i]=cb[i].slice(1);
      }
   cb[i]=cb[i].slice(0,-cb.length+i)+'[';
   cb[i]=overperiod(cb[i]);
   prover[i]=overprimer(cb[i],st0);
   }

let np=cb.length-1;
for(i=cb.length-2;i>=pn;i--)

   if(prover[i].length+cb[i].length>prover[np].length+cb[np].length)
      {
      if(prover[i]+cb[i]>prover[np]+(cb[np].repeat(Math.ceil((prover[i].length-prover[np].length+cb[i].length)/cb[np].length))))
         np=i;
      }
   else
      if(prover[i]+(cb[i].repeat(Math.ceil((prover[np].length-prover[i].length+cb[np].length)/cb[i].length)))>prover[np]+cb[np])
         np=i;

st0=prover[np];

let rr=cb[np].length-getpos(cb[np]);

fsopening=st0.slice(0,-rr);
rr%=cb[np].length;
fsperiod0=cb[np].slice(-rr)+cb[np].slice(0,-rr);
while(fsopening.slice(-fsperiod0.length)==fsperiod0)
   fsopening=fsopening.slice(0,-fsperiod0.length);

fsperiod1='!'.repeat(ocd(fsperiod0));
fsending='!'.repeat(ocd(fsopening));

cofcurrent='[[!!';
cofclass=0;
setfsarrays();

return fsopening+fsperiod0.repeat(nn)+fsperiod1.repeat(nn)+fsending;
}



// is st ε number
function isepsilon(st){
return st==''?false:st==col||st==bo?true:compare(st,booster(st))<1;}     // original
//return st==''?false:st==col||st==bo?true:(base(st)==''||isepsilon(base(st)))&&compare(st,booster(st))<1;}  // for non-standard forms

// largest ε number ≤ CNF st (if st < ε_0 then '')
function floorepsilon(st){
if(!Array.isArray(st))
   return st;
let t=st[st.length-1][0];   
while(Array.isArray(t)&&t!=0){
   st=t;
   t=st[st.length-1][0];}   
return t;
}

// is st Ω number
function isOmega(st)
{
//return st==''?false:st==col||st==bo?true:compare(col,booster(st))<1;
return st==''||st==bo?false:st==col?true:st<col&&compare(col,booster(st))<1;
}


// remove boosters of st < c
function floorOmega(st,c=col){   
//while(st!=''&&st!=col&&st!=c&&compare(c,booster(st))==1)
while(st!=''&&st!=col&&st!=c&&compare(c,booster(st))==1)
//while(st!=''&&(compare(c,st)==1||compare(c,booster(st))==1))
   st=base(st); 
return st;	
}

function sepsilon(st,e){
let s=st[st.length-1];
if(s[0]==e)
if(s[1]==1)
   st.pop();
else   
   s[1]--;
return st.length?st:'';   
}

function braintail(st,e){
let bra,i=0,s=[];
while(floorepsilon([st[i]])!=e)   
   i++;
let u=i;
while(i<st.length){
   s.push([st[i][0]==e?'':sepsilon(st[i][0],e),st[i][1]]);
   i++;}
let tail=st.slice(0,u);
if(!tail.length)
   tail='';
else if(tail.length==1&&tail[0][1]==1&&tail[0][0]!=''&&!Array.isArray(tail[0][0]))
   tail=tail[0][0];
return [s,tail];        
}

// ω ^ CNF st
function omegapower(st){
if(st!=''&&!Array.isArray(st))
   return st;
return [[st,1]];  
}

// compare CNFs st1, st2 (if st1<st2 then -1; if st1==st2 then 0; if st1>st2 then 1)
function comparecnf(st1,st2){
if(st1.toString()==st2.toString())
   return 0;
if(st1=='')
   return -1;
if(st2=='')
   return 1;
let b1=!Array.isArray(st1);
let b2=!Array.isArray(st2);
if(b1&&b2)
   return compare(st1,st2);
let c;
if(b1){
   c=compare(st1,floorepsilon(st2));
   return c==0?-1:c;}
if(b2){
   c=compare(floorepsilon(st1),st2);
   return c==0?1:c;}
/*b1=st1[0].length==2;            // to compare CNF and extended CNF
b2=st2[0].length==2;
if(b1^b2){
   if(b1)
      st1=cnf(st1,true);
   else
      st2=cnf(st2,true);
   }*/
let i1=st1.length-1;
let i2=st2.length-1;
do{
   //if(b1&&b2){                  // to compare CNF and extended CNF
   if(st1[0].length==2&&st2[0].length==2){
      c=comparecnf(st1[i1][0],st2[i2][0]);
      if(c!=0)
         return c;
      c=st1[i1][1]>st2[i2][1]?1:st1[i1][1]<st2[i2][1]?-1:0;
      }
   else{
      c=compare(st1[i1][0],st2[i2][0]);
      if(c!=0)
         return c;
      c=comparecnf(st1[i1][1],st2[i2][1]);
      if(c!=0)
         return c;
      c=comparecnf(st1[i1][2],st2[i2][2]);       
      }
   if(c!=0)
      return c;
   i1--;
   i2--;
   }
while(i1>=0&&i2>=0);
//if(i1<0&&i2<0)                // to compare CNF and extended CNF
//   return 0;
if(i1<0)
   return -1;
return 1;
}

// CNF st1 + CNF st2 
function sumcnf(st1,st2){
if(st1=='')
   return st2;
if(st2=='')
   return st1;
if(!Array.isArray(st1)){
   let z1=st1;
   st1=[[st1,1]];}
if(!Array.isArray(st2)){
   let z2=st2;
   st2=[[st2,1]];}
let b1=st1[0].length==2;
let b2=st2[0].length==2;
if(b1^b2){
   if(b1)
      st1=[[z1===undefined?floorepsilon(st1):z1,'',st1]];
   else
      st2=[[z2===undefined?floorepsilon(st2):z2,'',st2]];
   }
let s=st2.slice(-1);
let i=0;
if(b1&&b2){
   let c=comparecnf(s[0][0],st1[i][0]);
   while(c>0){
      i++;
      if(i<st1.length)
         c=comparecnf(s[0][0],st1[i][0]);
      else
      	break;
      }
   if(i==st1.length)
      return st2;
   if(c==0){
      st1[i][1]+=s[0][1];
      st2.pop();}
   }
else{
   let c0=compare(s[0][0],st1[i][0]);
   let c1=comparecnf(s[0][1],st1[i][1]);
   while(c0>0||(c0==0&&c1>0)){
      i++;
      if(i<st1.length){
         c0=compare(s[0][0],st1[i][0]);
         c1=comparecnf(s[0][1],st1[i][1]);}
      else
   	   break;
      }
   if(i==st1.length)
      return st2;
   if(c0==0&&c1==0){
      st1[i][2]=sumcnf(st1[i][2],s[0][2]);
      st2.pop();}
   }
return st2.concat(st1.slice(i));
}

// get CNF of st
function cnf(st,ext=false,b=true){
if(!Array.isArray(st)&&(st==''||isepsilon(st)))
   return st;
let c=[];
if(ext){
   if(!Array.isArray(st))  
      st=cnf(st);
   if(floorepsilon(st)=='')
      return st;
   let s,t,i=-1,e,brain,m,y=-1,h;
	for(s of st){
	   h=false;
		e=floorepsilon([s]);
		if(e==''){
		   brain='';
		   m=s;		
			}
		else if(s[0]==e){
		   brain='';
		   m=['',s[1]];	   
		   }
		else{   
			[brain,t]=braintail(s[0],e);	
		   if(brain.length==1&&!brain[0][0].length&&brain[0][1]==1)
		      brain='';
  	      m=[t,s[1]];
  	      h=t!=''&&s[1]==1&&!Array.isArray(t);
			}
 	   if(i<0||c[i][0]!=e||c[i][1].toString()!=brain.toString()){
  	      c.push([e,brain,h?t:[m]]);
 	  	   i++;}
 	   else{
 	      if(!Array.isArray(c[i][2]))
 	         c[i][2]=[[c[i][2],1]];
     	   c[i][2].push(m);
     	   }
      }

   if(b)
	for(s of c)
	   {
  	   s[1]=cnf(s[1],true);
      s[2]=cnf(s[2],true);
      }
   }
else{
   let s,t,i=-1;
   while(st){
      [s,st]=isepsilon(st)?[st,'']:[booster(st),base(st)];
      if(c.length==0||compare(t,s)<1){
         if(i<0||c[i][0]!=s){
            c.push([s,1]);
   	      i++;}
   	   else   
   	      c[i][1]++;
   	   t=s;}
     }
   for(s of c)
      s[0]=cnf(s[0]); 
   }            
return c;        	
}

function unone(st){
return st=='1'?'':st;}

function displayform(st,ext=false){
if(st=='')
    return 0;
if(!Array.isArray(st))
   return convertepsilon(st,ext);
if(ext){
   if(st[0].length==2)
      return displayform(st);   
   let i=st.length-1;
   let s='';
   let e,ex,m;
   while(i>=0){
      s+=' + ';
      e=st[i][0];
      if(e=='')
         s+=displayform(st[i][2]);
      else{  
         s+=convertepsilon(e,true);
         ex=st[i][1];
         m=displayform(st[i][2],true);
      	if(Array.isArray(st[i][2])&&st[i][2].length>1)
      	   m='('+m+')';
      	else
      		m=unone(m);
         if(ex!='')
      	   s+='<sup>'+displayform(ex,true)+'</sup>';
      	else if(m&&(s[s.length-1]=='!'||m[0]=='['))
      	//else if(m)
      		s+='·';
         s+=m;
         }
      i--;	
      }
   return s.slice(3); 
   }
else{
   let i=st.length-1;
   let s='';
   let ex;
   while(i>=0){
      s+=' + ';
      ex=st[i][0];
      if(Array.isArray(ex)){  
   	   s+='ω';
   	   if(ex.length!=1||ex[0][0]!=0||ex[0][1]!=1)
   	      s+='<sup>'+displayform(ex)+'</sup>';
      	s+=unone(st[i][1]);
      	}
      else if(ex=='')
         s+=st[i][1];
      else{
         s+=convertepsilon(ex);
         if(st[i][1]!='1'){
            if(s[s.length-1]=='!')
               s+='·';
            s+=st[i][1];
            } 
         }
      i--;	
      }
   return s.slice(3);
   }
}

function getle(cf,x,ex,b){
let le='';
if(b){
   let u=0;
   while(comparecnf(cf,[ex[u]])>0)
      u++;
   if(u>0)
      le=ex.slice(0,u);}
if(le.length==1&&le[0][1]==1&&le[0][0]!=''&&!Array.isArray(le[0][0]))
   return le[0][0];
else   
   return omegapower(le);
return le;
}

function cnftoarray(eex,ext,f,le='-'){

   // Klammersymbolen
   
   //if(ext)
   //   eex=cnf(JSON.parse(JSON.stringify(ex)),true);
   
   let s='';
   let i,j,p,pp,m;

   if(Array.isArray(eex)){
      /*for(i=0;i<eex.length;i++)
         if(!Array.isArray(eex[i][0]))
            eex[i][0]=cnf(eex[i][0],true,false);*/
      i=eex.length-1;
      
      //while(eex[i][0]!=f)i--;
      //while(i>=0&&(!Array.isArray(eex[i][0])||eex[i][0]!=f))i--;
      while(i>=0&&(eex[i][0]!=f))i--;
      if(i>=0)
         {
         p=eex[i][1];
         if(!p)p=[["",1]]
         //else if(ext)p=cnf(p,true);
         //p=p?p[0][1]:1;
         m=eex[i][2];
         j=i;
         while(j>=0&&(eex[j][0]==f))j--;
         }
      else
      	j=eex.length-1;

      }

if(le=='-')
   le=displayform(eex.slice(0,j+1),ext);

if(i>=0)
   {
   while(i>=0&&eex[i][0]==f)
      {
      s+=', ';
      if(ext)
         m=cnf(m,true);
      s+=displayform(m,ext);

      pp=[...p];
      
      i--;
      if(i>=0){
         p=eex[i][1];
         m=eex[i][2];
         if(!p)p=[["",1]]
         //else if(ext)p=cnf(p,true);
         }
         
      if(!pp[0][0])
         {
         let q=pp[0][1];
         if(i>=0&&eex[i][0]==f)
            if(!p[0][0]&&JSON.stringify(pp.slice(1))==JSON.stringify(p.slice(1)))
               {
               q-=p[0][1];
               s+=', 0'.repeat(q-1);
               }
            else if(p[0][0]&&JSON.stringify(pp.slice(1))==JSON.stringify(p))
               s+=', 0'.repeat(q-1);
            else
               s+=', 0'.repeat(q)+' @<sup>'+cnftoarray(JSON.parse(JSON.stringify(cnf(pp.slice(1),true,false))),ext,f)+'</sup>';
         else
            {
            if(pp.length>1)
               s+=', 0'.repeat(q)+' @<sup>'+cnftoarray(JSON.parse(JSON.stringify(cnf(pp.slice(1),true,false))),ext,f)+'</sup>';
            else
               s+=', 0'.repeat(q-1);
            
            }
         }
      else
         {

         s+=' @<sup>'+cnftoarray(JSON.parse(JSON.stringify(cnf(pp,true,false))),ext,f)+'</sup>';
         }
      }
   if(le!='-')
      if((pp[0][0]||pp.length>1)&&le=='0')
         le='';
      else le=', '+le;
   s=s.slice(2);
   }

if(le=='-')
   le='';
   
return s+le;
}

function mtoc(st,n=0)
{
let m='[c[c[c!!!';
if(st==col||!st||(n<=0&&st<m))
   return st;
if(st==m)
   return col;
return bb(mtoc(base(st),n),mtoc(booster(st),n-1));
}

function finremc(st)
{
if(st.length<2)
   return st;
let x1=st;
let x2='';
let y1=booster(x1);
while(y1<col)
   {
   x2=bb('',y1)+x2;
   x1=base(x1);
   y1=x1==col?'c[c!':booster(x1);
   }
if(booster(x1)==col)
   {
   let x5=x1;
   while(booster(x5)==col)
      x5=base(x5);
   x5=booster(x5);
   x5=x5?booster(x5):col;
   while(x5>='[c[c[c!!!'&&x5<col)
      x5=x5?booster(x5):col;
   if(x5>='c[c[c!!')
      return base(x1)+x2;
   }
return st;
}

function convertepsilon(st,ext=false){
if(!nlevels&&st==col)
   return 'ε<sub>0</sub>';

if(nlevels==1&&st==col)
   return 'Ω';

if(st==col||st==bo)
   return st;
    
if(spn)
   {
   if(st=='[[c![[c![[c![!!!!')
      return 'SVO';
   else if(st=='[[c![[c![[c![[c!!!!!')
      return 'LVO';
   else if(st=='[[c![c!!')
      return 'BHO';
   else if(st=='[[c[!!!')
      return 'BO';
   else if(st=='[[c[!![c!!')
      return 'TFB';
   else if(st=='[[c[c!!!')
      return 'EBO';
   else if(st=='[[c[c!![c!!')
      return 'SRO';
   else if(st=='[[c[c[c!!![c!!')
      return 'RO';
   }

/*if(st=='[[[[c!c!!c!')   
   return 'I';
if(st=='[c[c[c!!!')   
   return 'M';*/
let x=booster(st);
let beta=base(st);

let sy='';
let f=floorOmega(x);
//let j,maxx,ff;
let j,maxx;
//let exa;

let f1=card(x);
let f2=ecard(beta);
//f2=nexteps(ecard(beta),1);
//let l=nexteps(f2,2);

//if(f1==f2)
if(f1==nexteps(f2,1))
   {
   sy='φ';
   f=f1;
   j=f;
   maxx=nexteps(f,0);
   }
//else if(f1==l)
/*else if(floorOmega(x,l)==l)
   {
   sy='Φ';
   f=bb(l,l);
   f=bb(beta,f);
   j=bb(l,f);
   j=bb(beta,j);
   maxx=bb(l,nexteps(f,0));
   }*/
else if(f==col){
   sy='Φ';
   //ff=bb(col,col);
   //f=bb(floorOmega(beta,ff),ff);
   f=bb(col,col);
   f=bb(floorOmega(beta,f),f);
   j=bb(col,f);
   j=bb(floorOmega(beta,j),j);
   //maxx=bb(col,bb(f,bb(f,bb(f,''))));
   //maxx=bb(col,bb(f,bb(f,'')));
   //maxx=bb(col,bb(f,bb(f,f)));
   maxx=bb(col,bb(f,col));
   //ff=fs(ff,f);
   }
else if(f==bb(col,col)){
   sy='I-Φ';
   f=bb(f,col);
   f=bb(floorOmega(beta,f),f);
   j=bb(bb(col,col),f);
   j=bb(floorOmega(beta,j),j);
   //maxx=bb(bb(col,col),bb(f,bb(f,'')));
   //maxx=bb(bb(col,col),bb(f,bb(f,f)));
   maxx=bb(bb(col,col),bb(f,col));
   }
/*else if(f==bb(col,col)){
   sy='L';
   j=bb(col,col);
   j=bb(j,col);
   j=bb(floorOmega(beta,j),j);
   j=bb(col,j);
   j=bb(floorOmega(beta,j),j);  
   }
else if(f==bb(col,bb(col,col))){
   sy='R';
   j=bb(col,col);
   j=bb(j,col);
   j=bb(j,col);
   j=bb(floorOmega(beta,j),j);
   j=bb(col,j);
   j=bb(floorOmega(beta,j),j); 
   }*/
/*else if(f==bb(floorOmega(beta),col)){
   sy='φ';
   j=f;
   //maxx=bb(f,bb(f,bb(f,'')));
   //maxx=bb(f,bb(f,bb(f,f)));
   maxx=bb(f,bb(f,col));
   //ff=f;
   }*/
/*else if(x>col){
   sy='I';
   f=col;
   j=f;
   maxx='d';
   }*/
else if(x>='c[c[c!!'&&st<'[c[c[c!![[c[c[c!![c!!!!'){
   sy='M';
   //f='[c[c[c!!!';
   f=col;
   j=f;
   maxx='d';
   }
else if(x>col&&x<'c[c[[c[c[c!!![[c[c[c!!![c!!!!')
   {
   let x1=x;
   let x2='';
   let y1=booster(x1);
   //while(y1<'c[[c[c[c!!!!')
   while(y1<col)
      {
      x2=bb('',y1)+x2;
      x1=base(x1);
      y1=x1==col?'c[c!':booster(x1);
      }
   //if(x<'c[c[[c[c[c!!!!!'||x2>='[c!')
   let x4=booster(x1);
   x4=x4?booster(x4):col;
   //while(x4&&x4<col)
   while(x4>='[c[c[c!!!'&&x4<col)
      x4=x4?booster(x4):col;
   //if(x5>='[c[c[c!!!')
   
   //if(x<'c[c[[c[c[c!!!!!'||x2>='[c!'||(x>='c[c[[c[c[c!!!!!'&&x4<'[c[c[c!!!'))
   //if(x<'c[c[[c[c[c!!!!!'||x2>='[c!'||x4<'[c[c[c!!!')
   //if(x4<'[c[c[c!!!')
   if(x4<'c[c[c!!')
      {
      /*let x3=x;
      while(booster(x3)<col)
         x3=base(x3);
      x3=bb(x3,col);*/
      let x3=bb(x1,col);
      x3=bb(beta,x3);
      if(x2<x3)
         {
         //if(x1>col&&x2.length>2&&x2.slice(0,3)=='[c!')
         //   x2=x2.slice(3);
         /*if(booster(x1)==col)
            {
            let x5=x1;
            while(booster(x5)==col)
               x5=base(x5);
            x5=booster(x5);
            x5=x5?booster(x5):col;
            if(x5>='[c[c[c!!!')
               x1=base(x1);
            //x1=base(x1);
            }*/
            
         if(x>='c[c[[c[c[c!!!!!')
            {
            x1=finremc(x1);
            while(x1>col)
               {
               x2=bb('',mtoc(booster(x1)))+x2;
               x1=base(x1);
               }
            let x5='';
            while(beta.length>1)
               {
               x5=bb('',finremc(booster(beta)))+x5;
               beta=base(beta);
               }
            beta+=x5;
            beta=mtoc(beta,2);
            x=col+x2;
            }
            
         sy='I';
         f=col;
         j=f;
         maxx='d';
         }
      }
   }
/*else if(compare(bb(col,col),x)<1){
//else if(beta==''&&compare(bb(col,col),x)<1){
   sy='I';
   f=col;
   j=f;
   maxx=bb(f,bb(f,bb(f,'')));
   }*/
//if(sy!=''&&compare(bb(f,bb(f,bb(f,''))),x)>0&&(sy!='Ω'||compare(bb(col,j),x)==1)){
//if(sy!=''&&compare(bb(f,bb(f,bb(f,''))),x)>0){
if(sy!=''&&compare(maxx,x)>0){
//{
   let cf=cnf(f);
   let fx=floorOmega(x,f);
   let ex=cnf(x);
   let eex=cnf(JSON.parse(JSON.stringify(x)),true,false);
   //let eex=sy=='I'?exa:cnf(JSON.parse(JSON.stringify(x)),true,false);
   //let eex=cnf(JSON.parse(JSON.stringify(ex)),true,false);
   //let eex=cnf(JSON.parse(JSON.stringify(ex)),true);
   //let eex=cnf(ex,true,false);
   let le=getle(cf,x,ex,x!=f&&eex[0][0]!=f);
   while(beta){
      let x1=booster(beta);
      let fx1=floorOmega(x1,j);
      if(fx1==fx){
         let ex1=cnf(x1);
         //le=sumcnf(getle(cf,x1,ex1,x1!=j&&cnf(ex1,true,false)[0][0]!=j),le);
         le=sumcnf(getle(cf,x1,ex1,x1!=j&&cnf(JSON.parse(JSON.stringify(x1)),true,false)[0][0]!=j),le);
         //le=sumcnf(getle(cf,x1,ex1,x1!=j&&cnf(JSON.parse(JSON.stringify(ex1)),true,false)[0][0]!=j),le);
         //le=sumcnf(getle(cf,x1,ex1,x1!=j&&cnf(JSON.parse(JSON.stringify(ex1)),true)[0][0]!=j),le);
         beta=base(beta);}
      else{
         //if(fx==ff)
         //if(comparecnf(fx,ff)<1)
         if(!Array.isArray(eex))
            le=sumcnf(beta,le);
         else{
            let u=eex.length-1;
            //while(u>=0&&eex[u][0]==f)
            //alert(st);
            //if((u>=0&&compare(f,eex[u][0])<1)!=(u>=0&&comparecnf(f,eex[u][0])<1))
            //   alert(st);
            //while(u>=0&&compare(f,eex[u][0])<1)
            while(u>=0&&comparecnf(f,eex[u][0])<1)
            	u--;
            u++;
            let ca=comparecnf(eex[u][2],cnf(beta));
            le=sumcnf(ca==1?'':ca==0?[['',1]]:beta,le);
            }
         break;
         }
      }
   if(sy!='φ'&&(sy!='Φ'||fx==col)&&(sy!='I-Φ'||fx==bb(col,col))&&sy!='I'&&le.length==1&&le[0][1]==1&&le[0][0]=='')
   //if(sy!='φ'&&(sy!='Φ'||fx==l)&&(sy!='I-Φ'||fx==bb(l,l))&&sy!='I'&&le.length==1&&le[0][1]==1&&le[0][0]=='')
      le='';
   else{
      if(ext)   
         le=cnf(le,true);
      le=displayform(le,ext);
      if((sy=='φ'||(sy=='Φ'&&fx!=col)||(sy=='I-Φ'&&fx!=bb(col,col))||sy=='I')&&isFinite(le))
         le--;
      }
   if(sy=='φ'){
      if(fx==f)
         return 'ε<sub>'+le+'</sub>';
      if(fx==bb(f,f))
         return 'ζ<sub>'+le+'</sub>';
      if(fx==bb(bb(f,f),f))
         return 'η<sub>'+le+'</sub>';
      if(fx==bb(f,bb(f,f)))
         return 'Γ<sub>'+le+'</sub>';}
   if(sy=='Φ'&&fx==col)
      return 'Ω'+(le==''?'':'<sub>'+le+'</sub>');
   if(sy=='I-Φ'&&fx==bb(col,col))
      return 'I'+(le==''?'':'<sub>'+le+'</sub>');
   //if(sy!='φ'&&sy!='Φ'&&sy!='I-Φ')
   //   return sy+(le==''?'':'<sub>'+le+'</sub>');
   //if(sy=='M'&&fx=='c[c[c!!')
   if(sy=='M')
      return 'M'+(le==''?'':'<sub>'+le+'</sub>');
      
   // old version (without @)	
   /*	   
   if(Array.isArray(eex)){
      i=eex.length-1;
      while(eex[i][0]!=f)i--;
      p=eex[i][1];
      p=p?p[0][1]:1;
      m=eex[i][2];
      }
   else{
   	i=0;
   	p=1;
   	m=[["",1]];
   	}
   let q=p;
   while(q>0){
      s+=', ';
      if(q==p){
         i--;
         if(ext)
            m=cnf(m,true);
         s+=displayform(m,ext);
         if(i>=0){
            p=eex[i][1];
            m=eex[i][2];
            p=eex[i][0]!=f?0:p==''?1:p[0][1];}
         }
      else
         s+=0;
      q--;
      }
      */
   
   if(sy=='I')
      {
      let lene=eex.length-1;
      if(!eex[lene][1])
         {
         let lenee=eex[lene][2].length-1;
         if(!eex[lene][2][lenee][0])
            //eex[lene][2][lenee][1]--;
            eex[lene][2][lenee][1]-=2;
         }
      }
   
   let s=cnftoarray(eex,ext,f,le);
   
   //return sy+'('+s.slice(2)+', '+le+')';   
   //return sy+'('+s.slice(2)+le+')';
   return sy+'('+s+')';
   }
return bb(beta==''?'':(displayform(cnf(beta,ext),ext)),displayform(cnf(x,ext),ext));
}

function convert_old(st){
return (format>1?st:displayform(cnf(st,format),format)).toString().replaceAll('!',']');}
//return (format>1?st:JSON.stringify(cnf(st,format))).toString().replaceAll('!',']').replaceAll('"','');}

//function convert(st,b=true){
function convert(st,b=decompositionintoboosterslevels){
//if(b||!st||st==col||st==bo)
if(!b||!st||st==col||st==bo)
   {
   if(format<2&&(st=='[[c![[c![[c![!!!!'||st=='[[c![[c![[c![[c!!!!!'||st=='[[c![c!!'||st=='[[c[!!!'||st=='[[c[!![c!!'||st=='[[c[c!!!'||st=='[[c[c!![c!!'||st=='[[c[c[c!!![c!!'))
      spn=false;
   let s=(format>1?st:displayform(cnf(st,format),format)).toString().replaceAll('!',']');
   //if(format<2)
   if(!decompositionintoboosterslevels&&format<2)
   {
   if(st=='[[c!!')
      s+=' <small>(Small Cantor ordinal)</small>';
   else if(st=='[[c![[c!!!')
      s+=' <small>(Cantor ordinal)</small>';
   else if(st=='[[c![[c!![[c!!!')
      s+=' <small>(Large Cantor ordinal)</small>';
   else if(st=='[[c![[c![[c!!!!')
      s+=' <small>(Feferman–Schütte ordinal)</small>';
   else if(st=='[[c![[c![[c!![[c!!!!')
      s+=' <small>(Ackermann ordinal)</small>';
   else if(st=='[[c![[c![[c![!!!!')
      s+=' <small>(Small Veblen ordinal, SVO)</small>';
   else if(st=='[[c![[c![[c![[c!!!!!')
      s+=' <small>(Large Veblen ordinal, LVO)</small>';
   else if(st=='[[c![c!!')
      s+=' <small>(Bachmann-Howard ordinal, BHO)</small>';
   else if(st=='[[c[!!!')
      s+=' <small>(Buchholz ordinal, BO)</small>';
   else if(st=='[[c[!![c!!')
      s+=' <small>(Takeuti-Feferman-Buchholz ordinal, TFB)</small>';
   else if(st=='[[c[c!!!')
      s+=' <small>(Extended Buchholz ordinal, EBO)</small>';
   else if(st=='[[c[c!![c!!')
      s+=' <small>(Small Rathjen ordinal, SRO)</small>';
   else if(st=='[[c[c[c!!![c!!')
      s+=' <small>(Rathjen ordinal, RO)</small>';
   }
   spn=true;
   return s;
   }
else
   {
   let beta=base(st);
   //return (beta?convert(beta):'')+'['+convert(booster(st),true)+']';
   return (beta?convert(beta,b):'')+'['+convert(booster(st),b-1)+']';
   }
}
//return (format>1?st:JSON.stringify(cnf(st,format))).toString().replaceAll('!',']').replaceAll('"','');}



function rx(s,c,n,q){
count++;
let x=document.createElement('li');
x.id=s;
x.innerHTML=convert(s);
if(s==''||s.slice(-2)=='[!')
   x.style.cursor='default';
x=x.outerHTML;
if(q>0){
	let y=document.createElement(ulnar[indentvisible]);
   s=fs(c,'',n);
   n++;
   y.innerHTML=rx(s,c,n,q-1);
   x+=y.outerHTML;} 
return x;     
}

// small expansion of pair c > l
function se(c,l,q){
let n=0;
let s;
do{
   s=fs(c,'',n);
   n++;}
//while(l!='-'&&compare(s,l,true)<1)
while(l!='-'&&compare(s,l)<1)
return q==-1?s:rx(s,c,n,q);  	
}

function pl(c){
let e=0;
let l=c.previousSibling;
/*if(l==null){
   e++;
   l=c.parentNode.previousSibling;}*/ 

while(l==null){
   e++;
   c=c.parentNode;
   l=c.previousSibling;}  
   
while(l&&l.tagName!='LI'){
   e--;
   l=l.lastChild;}
return [l,e];}

function nl(c){
let l=c.nextSibling;

while(l==null){
   c=c.parentNode;
   l=c.nextSibling;}  
   
while(l&&l.tagName!='LI')
   l=l.firstChild;
return l;}

function cl(c){
while(c.lastChild.tagName==ulnar[indentvisible])
    c=c.lastChild;
return c;}

// small expansion of c
function smallexp(c,n=0){
if(c.id=='')
   return 0;
let l=pl(c)[0];
if(c.id.slice(-2)=='[!'&&l.id==c.id.slice(0,-2))
   return 0;
  
count++;
let s;
if(c.id==prevsmallexp)
   {s=fs(c.id,'',nextsmallexpn);
   nextsmallexpn++;
   n=nextsmallexpn;}
else
   {do{s=fs(c.id,'',n);
      n++;}
   while(l.id!='-'&&compare(s,l.id)<1);
   prevsmallexp=c.id;
   nextsmallexpn=n;
   }
let x=document.createElement('li');
x.id=s;
x.innerHTML=convert(s);
if(s==''||(s.slice(-2)=='[!'&&l.id==s.slice(0,-2)))
   x.style.cursor='default';
if(indentmode)
   if(c.previousSibling&&c.previousSibling.tagName==ulnar[indentvisible])
      l.insertAdjacentHTML('afterend',x.outerHTML);     
   else
      {let y=document.createElement(ulnar[indentvisible]);
      y.innerHTML=x.outerHTML;
      c.insertAdjacentHTML('beforebegin',y.outerHTML); 
      }  
else
	if(c.previousSibling==null)
	   c.insertAdjacentHTML('beforebegin',x.outerHTML);
	else
	   {let y=document.createElement(ulnar[indentvisible]);
      y.innerHTML=x.outerHTML;
	   l.insertAdjacentHTML('afterend',y.outerHTML); 
	   }
return n;  	
}

function smallexpefs(c,extra){
if(c.id=='')
   return 0;
let e=0;
let n=0;
do {
	n=smallexp(c,n);
	e++;}
while(n&&e<=extra);
}	

function smallexpefslong(c,l,extra){
let q;
do
   {q=pl(c)[0];
   smallexpefs(c,extra);
   c=q;}
while(c!=l);
}	

function singleexp(c,extra){
let n;
let l=pl(c)[0];
let q=c;
do {

	n=smallexp(q,0);
	if(n)
	   q=pl(q)[0];}
while(n);
if(extra)
   smallexpefslong(c,l,extra-1);
}	

function singleexplong(c,l,extra){
let q;
do
   {q=pl(c)[0];
   singleexp(c,extra);
   c=q;}
while(c!=l);
}	

function multipleexp(c,extra,n){
/*if(n==1)
   singleexp(c,extra);
else*/
	{if(!nextl)
	   nextl=pl(c)[0];
	   do 
	      {n--;
	   	singleexplong(c,nextl,n?0:extra);}
      while(n);
	}
}	

function countli(c){
if(c.tagName=='LI')
   return 1;
let n=0;   
for(let l=c.firstChild;l!=null;l=l.nextSibling)
   if(l.tagName==ulnar[indentvisible])
      n+=countli(l);
   else  
      n++;
return n;      
}

function expcolmarksupdate(){
let r=markedli.getBoundingClientRect();
let h=r.left-27+listc.scrollLeft;
let vc=listc.scrollTop+(r.top+r.bottom)/2;
//let vc=listc.clientHeight-listc.scrollTop-(r.top+r.bottom)/2;
let s=markedli.previousSibling;
let a=0;
let t=!markedli.id.length?false:markedli.id.length<2||markedli.id.slice(-2,-1)!='['||pl(markedli)[0].id!=markedli.id.slice(0,-2);
if(s&&s.id!='-'&&(!indentmode||s.tagName==ulnar[indentvisible]))
   {
   colmark.style.left=h-a+'px';
   colmark.style.top=vc-11+'px';
   colmark.hidden=false;
   a+=24;
   }
else
	colmark.hidden=true;
if(markedli.id&&t)
   {	
   smexmark.style.left=h-a+'px';
   smexmark.style.top=vc-11+'px';
   smexmark.hidden=false;
   a+=24;   
   expmark.style.left=h-a+'px';
   expmark.style.top=vc-11+'px';
   expmark.hidden=false;
   a+=24;
   }
else
   {
	smexmark.hidden=true;
	expmark.hidden=true;
	}
if(mulcounter>1&&t)
   {
   mulmark.style.left=h-a+'px';
   mulmark.style.top=vc-11+'px';
   mulmark.hidden=false;
   a+=24;
   }
else
	mulmark.hidden=true;
}

function setmarkedli(c,b=true){
if(markedli)
   markedli.style.outline='';
markedli=c;
markedli.style.outline='1px solid gainsboro';
if(b)
   mulcounter=1;
expcolmarksupdate();
}

function removebackground(c)
{if(c==markedli)
   c.style.background='';
else
	c.removeAttribute('style');
}

function formatting(c=list){
let l=lea?lea:markedli;
let r=l.getBoundingClientRect();
let vc=(r.top+r.bottom)/2;

for(let l=c.firstChild;l!=null;l=l.nextSibling)
   if(l.tagName==ulnar[indentvisible])
      formatting(l);
   else if(l.id!='-')
      l.innerHTML=convert(l.id);
expcolmarksupdate();
far[format].style.background='#d0ffd0'; 

r=l.getBoundingClientRect();
listc.scrollTop+=(r.top+r.bottom)/2-vc;
scrollli(l);
}

function updateli(c){
if(c)
if(c.id)
   c=document.getElementById(c.id);
else
   {
   c=nl(document.getElementById('-'));
   while(c.tagName==ulnar[indentvisible])
    	c=c.FirstChild;
   }
return c;
}

function psb(b=false){
if(b)
   ps.forEach(function(i){
      //if(i.id!=''||i.tagName==ulnar[indentvisible])
      //if(i.tagName==ulnar[indentvisible])
         removebackground(i);
      });
else
   ps.forEach(function(i){
      //if(i.id!=''||i.tagName==ulnar[indentvisible])
      //if(i.tagName==ulnar[indentvisible])
         i.style.background=eo>1?'#f8f8ff':'#fffff0';
      });
}

function mousetextupdate(x,y){
   //xs.style.left=x+(x*2<window.innerWidth?35:-xs.offsetWidth-15)+'px';
   xs.style.left=x+(x*2<window.innerWidth||25*Math.round(x/25)+15+xs.offsetWidth<window.innerWidth?35:-xs.offsetWidth-15)+'px';
   //xs.style.top=y-(y*2<window.innerHeight?(vero?-18:5):xs.offsetHeight-(vero+30))+'px';
   xs.style.top=y-(y*2<window.innerHeight||25*Math.round(y/25)-50+xs.offsetHeight<window.innerHeight?(vero?-18:5):xs.offsetHeight-(vero+30))+'px';
}

document.onmousemove=function(e){
   mousex=e.clientX;
   mousey=e.clientY;
   mousetextupdate(mousex,mousey);
}

function mouseoverupdate(c=''){
if(mousex)
   {if(!c)
      c=document.elementFromPoint(mousex, mousey);
   let u=new Event('mouseover');
   Object.defineProperty(u,'target',{value:c});
   document.dispatchEvent(u);
   }
}

function setps(c,n=''){
//n--;
let q=c.previousSibling;
//if(!b)
//   c=c.lastChild;
//exb[0]=q!=null&&q.id!='-';
exb[0]=q&&(indentmode?q.tagName==ulnar[indentvisible]:q.id!='-');
exb[1]=c.id!=''&&(c.id.slice(-2)!='[!'||pl(c)[0].id!=c.id.slice(0,-2));
//if(b)
   ps=[];
//else
//	ps.push(c);

if(exb[0])
if(n)
   {
   q=pl(c)[0];
   pairl[0]=n;
   do
      {
      ps.push(q);
      q=pl(q)[0];
      }
   while(q!=pairl[0]&&q.offsetTop+q.offsetHeight>listc.scrollTop-10);
   }
else if(indentmode) 
      /*{q=q.lastChild;
      ps.push(q);
      while(q.previousSibling&&q.previousSibling.tagName==ulnar[indentvisible])
         {q=q.previousSibling.lastChild;
         ps.push(q);}
      pairl[0]=pl(q)[0];}*/
      {q=q.lastChild;
      pairl[0]=q.previousSibling;
      if(!pairl[0])
         pairl[0]=pl(q)[0];
      else if(pairl[0].tagName==ulnar[indentvisible])
         pairl[0]=pl(pairl[0])[0];
      do
      	{ps.push(q);
      	q=pl(q)[0];
         }
      //while(q!=pairl[0]&&q.offsetTop+q.offsetHeight>listc.scrollTop-10);
      while(q!=pairl[0]);
            }
   else
      {let cc=q;
      if(q.tagName==ulnar[indentvisible]){
         cc=cl(cc);
         pairl[0]=cc.previousSibling;
         cc=cc.lastChild;}
      else
         pairl[0]=q.parentNode.previousSibling;
      //while(cc&&cc.offsetTop+cc.offsetHeight>listc.scrollTop-10)
      while(cc)
         {ps.push(cc);
         cc=cc.previousSibling;}}
else
   {pairb[0]=false;
   pairl[0]=document.getElementById('-');}
         	 
if(exb[1])
   {pairl[1]=pl(c)[0];
   pairb[1]=pairl[1].id!='-';} else
   {pairb[1]=false; 
   pairl[1]=document.getElementById('-');}
   
//if(n&&pairl[0].id!='-')
//   setps(pairl[0].parentNode,n,false);
}

function expwords(n){
let ord='th';
if (n %10 == 1 && n % 100 != 11)
   ord = 'st';
else if (n % 10 == 2 && n % 100 != 12)
   ord = 'nd';
else if (n % 10 == 3 && n % 100 != 13)
   ord = 'rd';

//return n<10?exp[n]:n+'-fold recursive expansion';
return n<10?exp[n]:'Recursivly expand '+n+ord+' times';
}

listc.onscroll=function(e){
   mousetag='';mousetagp=xs;
   mouseoverupdate();
}

window.onresize=function(e){
   mouseoverupdate(listc);
   mouseoverupdate();
   expcolmarksupdate();
}

document.onmouseover=function(e){
//if(vt){
if(e.target&&processing)
{
let onli=xs.hidden;
if(mousetag!=e.target&&!mousetagp.contains(e.target))
{
//count++;
keytcheck=true;
vero=70;
onli=false;
let c=e.target;
mousetag=c;
mousetagp=xs;
while(c.tagName=='SUB'||c.tagName=='SUP'||c.tagName=='BIG'||c.tagName=='SMALL')
   c=c.parentNode;
if(lea){
   removebackground(lea);
   psb(true);
   removebackground(pairl[0]);
   removebackground(pairl[1]);
   }
let h;
if(c.id=='counter'){
   h='<small>Total number of ordinals in the list</small>';
   xs.style.background='#ffffff';
   vero=0;
   }
else if(c.id=='oldversionlink'){
   h='<small>Link to old versions and other projects</small>';
   }
else if(c.id=='reset'){
   h='<div id="res1"'+(count>1?'':' style="font-style:italic"')+'><nobr id="res2"'+(count>1?' style="font-weight:bold"':'')+'>Reset list</nobr></div><i>use "R" key</i>';
   if(count>1)
      xs.style.background='#fffff0';
   }
else if(c.id=='uncreset'){
   h='<div><nobr id="res3" style="font-weight:bold">Set '+(uncountablemode?'':'un')+'countable mode and reset list</nobr></div><i>use "U" key</i>';
   xs.style.background='#fffff0';
   }
else if(c.id=='vtext'){
   h='<b>Hide</b> text near mouse cursor<br/><i>use "T" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='vsidebar'){
   h='<b>'+(sidebar.hidden?'Show':'Hide')+'</b> options<br/><i>use "Tab" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='decef'){
   h='<div id="decd1"'+(efs>0?'':' style="font-style:italic"')+'><nobr id="decd2"'+(efs>0?' style="font-weight:bold"':'')+'>Decrease</nobr> maximal number of new strings per expansion</div><i>use "-" key</i>';
   if(efs>0) 
      xs.style.background='#fffff0';
   }
else if(c.id=='incef'){
   h='<b>Increase</b> maximal number of new strings per expansion<br/><i>use "+" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='decdec'){
   h='<div id="decdec1"'+(decompositionintoboosterslevels?'':' style="font-style:italic"')+'><nobr id="decdec2"'+(decompositionintoboosterslevels?' style="font-weight:bold"':'')+'>Decrease</nobr> number of levels of decomposition into boosters</div><i>use Digit keys</i>';
   if(decompositionintoboosterslevels) 
      xs.style.background='#fffff0';
   }
else if(c.id=='incdec'){
   h='<b>Increase</b> number of levels of decomposition into boosters<br/><i>use Digit keys</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='decd'){
   h='<small><div id="dec1" style="line-height:1.2'+(di>0?'':' ;font-style:italic')+'"><nobr id="dec2"'+(di>0?' style="font-weight:bold"':'')+'>Decrease</nobr> maximal number of<br/>fundamental sequence elements,<br/>displayed near mouse cursor</div></small><i>use "<" key</i>';
   if(di>0) 
      xs.style.background='#fffff0';
   }
else if(c.id=='incd'){
   h='<small><div style="line-height:1.2"><b>Increase</b> maximal number of<br/>fundamental sequence elements,<br/>displayed near mouse cursor</div></small><i>use ">" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='ecfv'){
   h='<small><small><div style="line-height:1">Maximal number of new strings per expansion.</div></small></small>'; 
   xs.style.background='#fff';
   }
else if(c.id=='decintoboostersl'){
   h='<small><small><div style="line-height:1">Number of levels of decomposition into boosters.</div></small></small>'; 
   xs.style.background='#fff';
   }
else if(c.id=='dis'){
   h='<small><small><div style="line-height:1">Maximal number of fundamental sequence elements, displayed near mouse cursor.</div></small></small>'; 
   xs.style.background='#fff';
   }    
else if(c.id=='for2'){
   h='<small><div style="line-height:1.2">"Computer format", used by this program.<br/>(Note: in the list strings are displayed using <b>]</b>, <b>[</b>, <b>c</b> alphabet,<br/>but the program itself uses <b>!</b> instead of <b>]</b> to match Unicode order).</div></small><i>use "I" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='indentmode2'){
   h='<small>No indentation</small><br/><i>use "J" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='indentmode1'){
   h='<small>Indentation, aligned by fundamental sequences</small><br/><i>use "K" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='indentmode0'){
   h='<small>Indentation, aligned by recursive expansions</small><br/><i>use "L" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='for0'){
   h='<small><div style="line-height:1.2">With two exceptions (0 and '+bo+'),<br/>ordinals are displayed as sums of ω<sup>x</sup>n terms, n ∈ ℕ.<br/>ω<sup>1</sup>n is displayed as ωn.<br/>If x > 0, then ω<sup>x</sup>1 is displayed as ω<sup>x</sup>.<br/>If ω<sup>x</sup> = x (i. e. x is an epsilon number), then ω<sup>x</sup> is displayed as x.<br/>ω<sup>0</sup>n is displayed as n.<br/>x is displayed in the same format.<br/>Epsilon numbers are displayed using some special designations<br/>(e. g. Veblen function), or using "Computer format".</div></small><i>use "O" key</i>';
   xs.style.background='#f0fff0';
   }
else if(c.id=='for1'){
   h='<small><div style="line-height:1.2">Similar to the previous format, but if x ≥ ε<sub>0</sub>, then ω<sup>x</sup>n is<br/>displayed as ε<sup>y</sup>α, where ε is the largest epsilon number ≤ x.<br/>ε<sup>y</sup>1 is displayed as ε<sup>y</sup>.<br/>ε<sup>1</sup>α is displayed as εα.<br/>y and α are displayed in the same format.</div></small><i>use "P" key</i>';
   xs.style.background='#f0fff0';
   }    
else if(c.id!='xs'&&!xs.contains(c)){

let eo1=-3;
vero=0;
if(c.id=='mulmark'||c.id=='expmark'||c.id=='smexmark'||c.id=='colmark')
   {
   eo1=eo;
   eo=c.id=='mulmark'?mulcounter:c.id=='expmark'?1:c.id=='smexmark'?0:-1;
   c=markedli;
   vero=70;
   }
   
   if(eo1==-3&&c!=mousetag&&c.tagName=='LI')
      mousetagp=c;
   h='<nobr id="ex1">'+expwords(eo)+'</nobr>';
   //h+='<br/><small><i>Click "'+convert(initlargeordinal)+'" to add more elements of its fundamental sequence</i></small>';
   //h+='<br/><small><i>Click "'+convert(initlargeordinal)+'" to add more strings</i></small>';
   xs.style.background='#fff';
   //h+='<span id="extra1"'+(efs==0||eo<0?' hidden':'')+'> with <nobr id="extra2">'+efs+'</nobr> extra fs element<nobr id="extra3">'+(efs==1?'':'s')+'</nobr></span>';  
   h+='<span id="extra1" hidden> with <nobr id="extra2">'+efs+'</nobr> extra fs element<nobr id="extra3">'+(efs==1?'':'s')+'</nobr></span>';  
   //if(c.tagName=='LI'&&c.id!=null&&c.id!='dots'){
   if(c.tagName=='LI'){
      lea=c;

      setps(c,eo1>-3&&eo>1?nextl:'');

      let i=eo<0||c!=markedli?0:1;
      let b=exb[i]; 
      //h+='<span id="ex4"'+(b?'':' hidden')+'>';                    
      //h+=' of ';
      h+='<span id="ex4"'+(b?'':' hidden')+'> ';
      //let l=pairl[i];
      let l=eo1>-3&&eo>1?nextl:pairl[i];
      h+='<nobr id="ex2">'+(l.id!='-'?'pair ':'')+'</nobr>';
      h+='<nobr id="ex3">'+(l.id!='-'?(l.innerHTML+', '):'')+'</nobr>';
      h+=c.innerHTML;
      if(b&&eo!=-2&&c==markedli){
         xs.style.background=i==0?'#fffaf0':eo1>-3&&eo>1?'#f0f0ff':eo>0?'#f0fff0':'#f0ffff';
         l.style.background=i==0?'#fffae0':eo1>-3&&eo>1?'#e0e0ff':eo>0?'#f4fff7':'#f4ffff';
         c.style.background=i==0?'#fff0e0':eo1>-3&&eo>1?'#e0d0ff':eo>0?'#e0ffe0':'#f0ffff';
         if(i==0||(eo1>-3&&eo>1))
            psb();
         }
      else if(c!=markedli)
         {
         xs.style.background='#fff';
         c.style.background='#fbfbfb';
         }
      else
         {
         xs.style.background='#fafafa';
         c.style.background='#fbfbfb';
         }
      h+='</span>';          
      //h='<div id="ex7"'+(!b||((eo==-2||c!=markedli)&&c.tagName=='LI')?' hidden':'')+'><span id="ex6" style="font-weight:'+(b?'bolda':'normal')+';font-style:'+(b?'normal':'italic')+'"><nobr id="ex5">'+(b?'Do ':'')+'</nobr>'+h+'</b>';   
      h='<div id="ex7"'+(!b||((eo==-2||c!=markedli)&&c.tagName=='LI')?' hidden':'')+'><span id="ex6" style="font-weight:'+(b?'bolda':'normal')+';font-style:'+(b?'normal':'italic')+'">'+h+'</b>';        
      if(eo1>-3&&markedli.id==initlargeordinal)
         {
         h+=' ';
         vero=36;
         }
      else
         h+='<br/>'
      h+='<i><small>(use "'+(eo>1?'C':eo>0?'Enter':eo<0?'Backspace':'Space')+'" key)</small></i></span>';
      
      if(eo1==-3)
      {
      //h+='<br/></div><b>'+c.innerHTML+'</b><span'+(false?'':' id="fsd"')+(di>0?'':' hidden')+'> fundamental sequence:'; 
      if(c.id=='')
         {
         cofcurrent='';
         cofclass=1;
         fscurrent='';
         fsnumber=1;
         }
      else
         {
         fs(c.id,'',0);
         //if(!cofclass&&isOmega(c.id))
         if(!cofclass&&getepslevel(c.id)>0)
            cofclass=4;
         }
      let cc=card(c.id);
      let ccc=cardclass;
      h+='<br/></div><b>'+c.innerHTML+'</b><span'+(false?'':' id="fsd"')+(di>0?'':' hidden')+'><br/>cof: '+convert(cofcurrent)+(cofclass?'<small> ('+cofclasslist[cofclass]+')</small>':'')+'<br/>card: '+convert(cc)+'<small> ('+cardclasslist[ccc]+')</small>'+'<br/>fs <small>(<span id="spps">'+(subperiodpositionshift+1)+'</span>/'+fsnumber+')'+(fsnumber>1?' <i>(use "←", "→" keys)</i>':'')+'</small>:'; 
      if(c.id=='')
         h+='<br>'+'   <i>empty</i>';
      else
         {
         fsn=0;
         fsp=c.id.slice(-2)!='[!';
         fsl=c.id;
      	for(let i=0;i<(fsp?di:1);i++){   	      
      	   //if(vt)h+='<li>   '+i+': '+convert(fs(fsl,'',fsn))+'</li>';
      	   if(vt)h+='<li id="fselement'+fsn+'">   '+i+': '+convert(fs(fsl,'',fsn))+'</li>';
      	   fsn++;}  
      	if(fsp)      
   	      h+='<li id="dots">   ... '+(gtkey||ltkey?'<i><small>(use "<", ">" keys)</small></i>':'')+'</li>';   
   	   }
   	}
   	   
   	h+='</span>';                  
      }
   else
      {
      h='<div id="ex7"'+((eo==-2||c!=markedli)&&c.tagName=='LI'?' hidden':'')+'>'+h+'</div>';
      onli=true;
      }
   if(eo1>-3)
      eo=eo1;
   }
else
   lea='';
xs.innerHTML=h;}
xs.hidden=!vt||onli;
mousetextupdate(mousex,mousey);  
}}

document.onmouseleave=function(e){
   mouseoverupdate(listc);
   xs.hidden=true;
}

function scrollli(c)
{if(c)
{let lx=listc.scrollLeft;
let ly=listc.scrollTop;
$(c).wrapInner('<ul1 style="padding-right: 27px">');
let u=c.firstChild;
let r=u.getBoundingClientRect();
let rc=c.getBoundingClientRect();
let r1=listc.getBoundingClientRect();
let bx=r.left<r1.left?-1:r.right>r1.right?1:0;
let by=rc.top<r1.top+3?-1:rc.bottom>r1.bottom-3?1:0;
if(by<0)
   if(c.id=='')
      listc.scrollTop=-listc.scrollHeight;
   else
      {u.scrollIntoView({inline: 'end'});
      listc.scrollTop-=3+r.top-rc.top;}
else 
   if(by>0)
   {listc.style.overflowX='auto';
   if(c.id==initlargeordinal)
      listc.scrollTop=0;
   else
      {u.scrollIntoView({block: 'end', inline: 'end'});
      listc.scrollTop+=3-r.bottom+rc.bottom;}
   listc.style.overflowX='overlay';
   }
else
	u.scrollIntoView({inline: 'end'});
if(!bx)
   listc.scrollLeft=lx;
if(!by)
   listc.scrollTop=ly;
u.removeAttribute('style');
$(u).contents().unwrap();}
}

list.onclick=function(e){
processing=false;
let initscroll=listc.scrollTop;
//if(markedli)
//   markedli.style.outline='';
//markedli='';
//list.hidden=true;
//if(eo!=-2){
let c=e.target;
while(c.tagName=='SUB'||c.tagName=='SUP'||c.tagName=='SMALL')
   c=c.parentNode;
if(c.id!='list'&&c.tagName=='LI'){
   if(!nextlb)
      {
      nextl='';
      mulcounter=1;
      }
if(c!=markedli)
   setmarkedli(c)
else if(c.id!=''){
   if(eo!=-2){
   let sc;
   let sc1=c;
   if(eo<0){
   setps(c);
   c=c.previousSibling;
   if(c!=null)
   {if(indentmode)
      {if(c.tagName==ulnar[indentvisible])
         {ps.forEach(function(i){
            while(i.parentNode.childElementCount==1)
               $(i).unwrap();
            i.remove();
            count--;
            });
         prevsmallexp='-';
         }
      }
   else {if(c.id!='-')
   {prevsmallexp='-';
   if(c.tagName==ulnar[indentvisible])
      {c=cl(c);             
      count-=countli(c);
      sc=c.previousSibling;   
      c.remove();
      }
   else{
      let q=c;
      sc=c.parentNode.previousSibling;
      while(c!=null){        
         c=c.previousSibling;
         count-=countli(q);
         q.remove();
         q=c;}
      }
   }
   }
   }}
   else{  
      if(eo==0)
         smallexpefs(c,efs);
      else
      	multipleexp(c,efs,eo);
      scrollli(pl(c)[0]);
      }
       
   counter.innerHTML='Counter: '+count;
   reset.style.opacity=count==1?0.4:1;
   uncreset.innerHTML=count==1?'Change mode':'Change mode and reset list';
   mouseoverupdate(sc1);
   expcolmarksupdate();
   }
}}
listc.scrollTop=initscroll;
processing=true;
mousetag='';mousetagp=xs;
mouseoverupdate();
}

function seteo(i)
{
eo=i;
}

function doexpcol(c)
{
let eo1=eo;
seteo(c=='Space'?0:c=='Backspace'?-1:1);
if(c=='KeyC')
   {
   nextlb=true;
   mulcounter++;
   }
else if(c=='Enter')
   {
   nextlb=true;
   nextl='';
   mulcounter=2;
   }
mouseoverupdate(markedli);
markedli.click();
//scrolly(markedli);
scrollli(markedli);
seteo(eo1);
mousetag='';mousetagp=xs;
mouseoverupdate();
nextlb=false;
expcolmarksupdate();
}

mulmark.onclick=function(e){
doexpcol('KeyC');
}

expmark.onclick=function(e){
doexpcol('Enter');
}

smexmark.onclick=function(e){
doexpcol('Space');
}

colmark.onclick=function(e){
doexpcol('Backspace');
}

switchformat.onclick=function(e){
let c=e.target;
while(c.tagName=='SUB'||c.tagName=='SUP')
   c=c.parentNode;
if(c.tagName=='TD'){
   let i=parseInt(c.id[3]);
   if(i!=format){
      far[format].style.background='#fff';
      format=i;
      formatting();
      }
   }
}

switchindentmode.onclick=function(e){
let c=e.target;
//if(c.tagName=='TD'){
if(c.tagName=='DIV'){
   let i=parseInt(c.id[10]);
   if(i==2&&indentvisible)
      {
      let u=new KeyboardEvent("keydown",{code:"KeyJ"});
      document.dispatchEvent(u);
      }
   else if(i<2&&(!indentvisible||i!=indentmode))
      {
      let u=new KeyboardEvent("keydown",{code:i?"KeyK":"KeyL"});
      document.dispatchEvent(u);
      }
   }
}

vtext.onclick=function(e){
let c=e.target;
//while(c.tagName!='TD')
//   c=c.parentNode;
if(vt){
   c.style.background='#fff';
   //c.style.color='#fff';
   vt=false;
   xs.hidden=true;
   }
else{
   c.style.background='#d0ffd0';
   //c.style.color='#000';
   vt=true;
   xs.hidden=false;
   mouseoverupdate();
   }      
}

vsidebar.onclick=function(e){
if(sidebar.hidden){
   sidebar.hidden=false;
   listc.style.right='240px';
   listc.style.overflowY='overlay';
   //listc.style.marginRight='17px';
   list.style.minWidth='calc(100% - 121px)';
   vsidebars.style.right='257px';
   counter.style.right='260px';
   vsidebar.innerHTML='»';
   }
else{
   sidebar.hidden=true;
   listc.style.right='0';
   listc.style.overflowY='auto';
   //listc.style.marginRight='0';
   let ssw=listc.scrollWidth-listc.clientWidth;
   if(listc.scrollLeft>=ssw-17)
      listc.scrollLeft=ssw;
   list.style.minWidth='calc(100% - 104px)';
   vsidebars.style.right='17px';
   counter.style.right='30px';
   vsidebar.innerHTML='«';
   }  
}

decef.onclick=function(e){
if(efs>0){
   efs--;
   //ecfv.innerHTML='   '+(efs+1)+'   ';
   ecfv.innerHTML='strings per<br/>expansion: '+(efs+1);
   if(efs==0){
      //ecfv.style.background='#fff';
      //decef.style.color='#eeeeee';
      decef.style.opacity=0.4;
      decef.style.cursor='default';
      xs.style.background='#fff';
      if(document.getElementById('decd1')!=null){
         decd1.style['font-style']='italic';
         decd2.style['font-weight']='normal';
         }
      } 	
   }      
}

incef.onclick=function(e){
efs++;
//ecfv.innerHTML='   '+(efs+1)+'   ';
ecfv.innerHTML='strings per<br/>expansion: '+(efs+1);
if(efs==1){
   //decef.style.color='#000';
   decef.style.opacity=1;
   decef.style.cursor='pointer';
   //ecfv.style.background='#d0ffd0';
   }    
}

decdec.onclick=function(e){
if(decompositionintoboosterslevels>0){
   decompositionintoboosterslevels--;
   formatting();
   decintoboostersl.innerHTML='   '+decompositionintoboosterslevels+'   ';
   if(!decompositionintoboosterslevels){
      decintoboostersl.style.background='#fff';
      decdec.style.color='#eeeeee';
      decdec.style.cursor='default';
      xs.style.background='#fff';
      if(document.getElementById('decdec1')!=null){
         decdec1.style['font-style']='italic';
         decdec2.style['font-weight']='normal';
         }
      }
   }      
}

incdec.onclick=function(e){
decompositionintoboosterslevels++;
formatting();
decintoboostersl.innerHTML='   '+decompositionintoboosterslevels+'   ';
if(decompositionintoboosterslevels==1){
   decdec.style.color='#000';
   decdec.style.cursor='pointer';
   decintoboostersl.style.background='#d0ffd0';
   }    
}

decd.onclick=function(e){
if(di>0){
   di--;
   dis.innerHTML='   '+di+'   ';
   if(di==0){
      dis.style.background='#fff';
      decd.style.color='#eeeeee';
      decd.style.cursor='default';
      xs.style.background='#fff';
      if(document.getElementById('dec1')!=null){
         dec1.style['font-style']='italic';
         dec2.style['font-weight']='normal';
         }
      } 	
   }      
}

incd.onclick=function(e){
di++;
dis.innerHTML='   '+di+'   ';
if(di==1){
   decd.style.color='#000';
   decd.style.cursor='pointer';
   dis.style.background='#d0ffd0';
   }    
}

function resetlist(m=uncountablemode)
{
ps=[];
nextl='';
mulcounter=1;
prevsmallexp='-';
uncountablemode=m;
bo=uncountablemodeinitnames[m]+(nlevels==2?'':', nlevels = '+nlevels);
initlargeordinal=bo;
list.innerHTML='<li id="-" hidden></li>';
let y=document.createElement('li');
y.id=initlargeordinal;
y.innerHTML=convert(initlargeordinal);
document.getElementById('-').insertAdjacentHTML('afterend',y.outerHTML);
setmarkedli(document.getElementById(initlargeordinal));
count=1;
counter.innerHTML='Counter: 1';
window.scrollTo(0,0);
reset.style.opacity=0.4;
uncreset.innerHTML='Change mode';
if(document.getElementById('res2')!=null)
   {
   xs.style.background='#fff';
   res1.style['font-style']='italic';
   res2.style['font-weight']='normal';
   }
else if(document.getElementById('res3')!=null)
   res3.innerHTML='Set '+(uncountablemode?'':'un')+'countable mode and reset list';
mouseoverupdate();
}

function indentul0(c){
if(c.childElementCount<1)
   {$(c).contents().unwrap();
   return;}
if(c.childElementCount>1)
   {$(c).wrapInner('<'+ulnar[indentvisible]+'>');
   c=c.firstChild;
   c.before(c.firstChild);
   if (c.previousSibling.tagName==ulnar[indentvisible])
      {indentul0(c.previousSibling);
      $(c.previousSibling).contents().unwrap();
      indentul0(c);
      $(c).contents().unwrap();
      }
   else
      indentul0(c);
   }
}

function indentul1(c){
if(c.childElementCount<1)
   {$(c).contents().unwrap();
   return;}
if(c.childElementCount>1)
   {$(c).wrapInner('<'+ulnar[indentvisible]+'>');
   c=c.lastChild;
   c.after(c.lastChild);
   if (c.nextSibling.tagName==ulnar[indentvisible])
      {indentul1(c.nextSibling);
      $(c.nextSibling).contents().unwrap();
      indentul1(c);
      $(c).contents().unwrap();
      }
   else
      indentul1(c);
   }
}

function indenttransform(){
indentmode=1-indentmode;
if(list.childElementCount==3)
if(indentmode)
   indentul1(list.children[1]);
else
   indentul0(list.children[1]);
}

function indentvisibletransform(e,b=true){
//if(!b||e.tagName==ulnar[1-indentvisible])
   {
   
   //e.tagName=ulnar[1-indentvisible];
   e.childNodes.forEach(function(i){
      if(i.tagName==ulnar[1-indentvisible])
         indentvisibletransform(i);
      });
   if(b)
      $(e).replaceWith('<'+ulnar[indentvisible]+'>'+$(e).html()+'</'+ulnar[indentvisible]+'>');
   }
}

reset.onclick=function(e)
{
resetlist();
}

uncreset.onclick=function(e)
{
resetlist(1-uncountablemode);
}

function fselementsupdate()
{
if(fsp&&document.getElementById('fsd')!=null)
   {
   fs(fsl,'',0);
   document.getElementById('spps').innerHTML=subperiodpositionshift+1;
   for (let e=0;e<fsn;e++)
      document.getElementById('fselement'+e).innerHTML='   '+e+': '+convert(fs(fsl,'',e));
   }
}

document.addEventListener('keydown',function(e){
if(!e.ctrlKey){
let c=e.code;
if(c.slice(0,5)=='Digit')
{
let i=c.slice(5);
if(i!=decompositionintoboosterslevels)
   {
   decompositionintoboosterslevels=parseInt(i);
   formatting();
   decintoboostersl.innerHTML='   '+decompositionintoboosterslevels+'   ';
   decintoboostersl.style.background=decompositionintoboosterslevels?'#d0ffd0':'#fff';
   decdec.style.color=decompositionintoboosterslevels?'#000':'#eeeeee';
   decdec.style.cursor=decompositionintoboosterslevels?'pointer':'default';
   if(document.getElementById('decdec1')!=null)
      {
      xs.style.background=decompositionintoboosterslevels?'#fffff0':'#fff';
      decdec1.style['font-style']=decompositionintoboosterslevels?'normal':'italic';
      decdec2.style['font-weight']=decompositionintoboosterslevels?'bold':'normal'; 
      }
   }
}
else if(c=='Minus'||c=='NumpadSubtract'){
if(efs>0){
   efs--;
   //ecfv.innerHTML='   '+(efs+1)+'   ';
   ecfv.innerHTML='strings per<br/>expansion: '+(efs+1);
   if(document.getElementById('extra1')!=null){
      if(efs==0)
         extra1.hidden=true;
      extra2.innerHTML=efs;
      extra3.innerHTML=efs==1?'':'s';   
      }    
   if(efs==0){
      //ecfv.style.background='#fff';
      //decef.style.color='#eeeeee';
      decef.style.opacity=0.4;
      decef.style.cursor='default';
      if(document.getElementById('decd1')!=null){
         xs.style.background='#fff';
         decd1.style['font-style']='italic';
         decd2.style['font-weight']='normal'; 
         }            
      }
   }
}     	
else if(c=='Equal'||c=='NumpadAdd'){
   efs++;
   //ecfv.innerHTML='   '+(efs+1)+'   '; 
   ecfv.innerHTML='strings per<br/>expansion: '+(efs+1);
   if(document.getElementById('extra1')!=null){
      if(efs==1&&eo>=0)
         extra1.hidden=false;
      extra2.innerHTML=efs;
      extra3.innerHTML=efs==1?'':'s';   
      }     
   if(efs==1){
      //decef.style.color='#000';
      decef.style.opacity=1;
      decef.style.cursor='pointer';
      //ecfv.style.background='#d0ffd0';
      if(document.getElementById('decd1')!=null){
         xs.style.background='#fffff0';
         decd1.style['font-style']='normal';
         decd2.style['font-weight']='bold';
         }
      }    	 	
   }
else if(c=='Comma'){
if(di>0){
   di--;
   if(ltkey){
      ltkey--;
      if(!gtkey&&!ltkey&&typeof dots!=='undefined')dots.innerHTML='   ... ';
      }
   dis.innerHTML='   '+di+'   '; 
   if(document.getElementById('fsd')!=null){
      if(fsp){
      	fsn--;
      	if(typeof dots!=='undefined')
            dots.previousSibling.remove();}             
      if(di==0)
         fsd.hidden=true;}        
   if(di==0){
      dis.style.background='#fff';
      decd.style.color='#eeeeee';
      decd.style.cursor='default';
      if(document.getElementById('dec1')!=null){
         xs.style.background='#fff';
         dec1.style['font-style']='italic';
         dec2.style['font-weight']='normal'; 
         }                        
      }
   }
}     	
else if(c=='Period'){
   di++;
   if(gtkey){
      gtkey--;
      if(!gtkey&&!ltkey&&typeof dots!=='undefined')dots.innerHTML='   ... ';
      }
   dis.innerHTML='   '+di+'   '; 
   if(document.getElementById('fsd')!=null){ 
      if(fsp){     	
         let y=document.createElement('li');
         y.id='fselement'+fsn;
         y.innerHTML='   '+(di-1)+': '+convert(fs(fsl,'',fsn));
         fsn++;
         if(typeof dots!=='undefined')
            dots.insertAdjacentHTML('beforebegin',y.outerHTML);}                
      if(di==1)
         fsd.hidden=false;}       
   if(di==1){
      decd.style.color='#000';
      decd.style.cursor='pointer';
      dis.style.background='#d0ffd0';
      if(document.getElementById('dec1')!=null){
         xs.style.background='#fffff0';
         dec1.style['font-style']='normal';
         dec2.style['font-weight']='bold';
         }        
      }
   }    
else if(c=='KeyT')
if(vt){
   vtext.style.background='#fff';
   vt=false;
   xs.hidden=true;
   keytcheck=false;
   }
else{
   vtext.style.background='#d0ffd0';
   vt=true;
   if (xs.innerText.slice(0,exp[0].length)!=exp[0])
      xs.hidden=false;
   if(keytcheck) 
      {mousetag='';mousetagp=xs;
      mouseoverupdate();}
   }
else if(c=='Tab'){
e.preventDefault();
if(sidebar.hidden){
   sidebar.hidden=false;
   listc.style.right='240px';
   listc.style.overflowY='overlay';
   listc.scrollBy(240,0);
   list.style.minWidth='calc(100% - 121px)';
   vsidebars.style.right='257px';
   counter.style.right='260px';
   vsidebar.innerHTML='»';
   }
else{
   listc.scrollBy(-240,0);
   sidebar.hidden=true;
   listc.style.right='0';
   listc.style.overflowY='auto';
   let ssw=listc.scrollWidth-listc.clientWidth;
   if(listc.scrollLeft>=ssw-17)
      listc.scrollLeft=ssw;
   list.style.minWidth='calc(100% - 104px)';
   vsidebars.style.right='17px';
   counter.style.right='30px';
   vsidebar.innerHTML='«';
   }
}
else if(c=='KeyR'){
   resetlist();} 
else if(c=='KeyU'){
   resetlist(1-uncountablemode);} 
else if(c=='KeyI'||c=='KeyO'||c=='KeyP'){
   let i=c=='KeyI'?2:c=='KeyP'?1:0;
   if(i!=format){
      far[format].style.background='#fff';
      format=i;
      formatting();
      if(document.getElementById('ex6')!=null){
         mousetag='';mousetagp=xs;
         mouseoverupdate(lea);}
      }
   }
else if(c=='KeyJ'||c=='KeyK'||c=='KeyL'){
   let i=c=='KeyJ'?2:c=='KeyK'?1:0;
   if(i==2&&indentvisible)
      {
      indentar[indentmode].style.background='#fff';
      indentar[2].style.background='#d0ffd0';
      }
   else if(i<2&&(!indentvisible||i!=indentmode))
      {
   	indentar[2].style.background='#fff';
   	indentar[indentmode].style.background='#fff';
      indentar[i].style.background='#d0ffd0';
      }
  if((c=='KeyK'&&!indentmode)||(c=='KeyL'&&indentmode))
      {
      //let initscroll=listc.scrollTop;
      indenttransform();
      mousetag='';
      if(lea&&lea.style.background)
        {scrollli(lea);
         scrollli(pairl[1]);}
      mouseoverupdate();
      }
   if(((c=='KeyK'||c=='KeyL')&&!indentvisible)||(c=='KeyJ'&&indentvisible))
      {
      //let initscroll=listc.scrollTop;
      indentvisible=1-indentvisible;
      indentvisibletransform(list,false);
      mousetag='';
      if(lea)
         lea=document.getElementById(lea.id);
      if(pairl[0])
         pairl[0]=document.getElementById(pairl[0].id);
      if(pairl[1])
         pairl[1]=document.getElementById(pairl[1].id);
      if(lea&&lea.style.background)
        {scrollli(lea);
         scrollli(pairl[1]);}
      mouseoverupdate();
      }
   nextl=updateli(nextl);
   markedli=updateli(markedli);
   setmarkedli(markedli,false);
   expcolmarksupdate();
   }
   
else if(c=='Space'||c=='Enter'||c=='KeyC'||c=='Backspace'){
   if(markedli)
      doexpcol(c);
   }
else if(c=='ArrowUp'){
   if(markedli)
      {let c=pl(markedli)[0];
      if(c.id=='-')
         c=markedli;
         {setmarkedli(c);
         scrollli(c);
         mousetag='';mousetagp=xs;
         mouseoverupdate();
         }
      }
   }
else if(c=='ArrowDown'){
   let c=(markedli&&markedli.id!=initlargeordinal)?nl(markedli):markedli;
      {  setmarkedli(c);
         scrollli(c);
         mousetag='';mousetagp=xs;
         mouseoverupdate();
      }
   }
else if(c=='ArrowLeft'){
   if(fsnumber>1)
      {
      fscurrent='';
      subperiodpositionshift--;
      if(subperiodpositionshift<0)
         subperiodpositionshift=fsnumber-1;
      fselementsupdate();
      }
   }
else if(c=='ArrowRight'){
   if(fsnumber>1)
      {
      fscurrent='';
      subperiodpositionshift++;
      if(subperiodpositionshift>=fsnumber)
         subperiodpositionshift=0;
      fselementsupdate();
      }
   }
else if(c=='KeyM'){
   nlevels++;
   bolevels++;
   initlargeordinalupdate();
   }
else if(c=='KeyN'){
   if(nlevels)
      {
      nlevels--;
      bolevels--;
      }
   initlargeordinalupdate();
   }
/*else if(c=='KeyB'){
   if(bolevels<nlevels)
      bolevels++;
   initlargeordinalupdate();
   }
else if(c=='KeyV'){
   if(bolevels)
      bolevels--;
   initlargeordinalupdate();
   }*/
else if(c=='KeyA'){
   window.prompt("Copy to clipboard: Ctrl+C", markedli.id);
   }
else if(c=='KeyS'){
   window.prompt("Copy to clipboard: Ctrl+C", convert(markedli.id));
   }
mousetextupdate(mousex,mousey);	 	       	
}}
);

function initlargeordinalupdate()
{if(bolevels>nlevels)
   bolevels=nlevels;
fscurrent='';
leastr=nlevels>1?'['.repeat(nlevels-2)+col+'!'.repeat(nlevels-2):'d';
leastuncounable=nlevels?'['.repeat(nlevels-1)+col+'!'.repeat(nlevels-1):'d';
initlargeordinal=nlevels==bolevels?bo:'['.repeat(bolevels)+('['.repeat(nlevels-bolevels)+col+'!'.repeat(nlevels-bolevels)).repeat(2)+'!'.repeat(bolevels);
resetlist();
}

window.onkeydown = function(e) { 
  return !((e.keyCode==32||e.keyCode==38||e.keyCode==40) && e.target == document.body);
};

let uncountablemode=0;
let uncountablemodeinitnames=['Some large countable ordinal','Some large uncountable ordinal'];
let bo=uncountablemodeinitnames[uncountablemode],col='c',eo=0,efs=0,
//exp=['expansion','recursive expansion','double recursive expansion','triple recursive expansion','quadruple recursive expansion','quintuple recursive expansion','sextuple recursive expansion','septuple recursive expansion','octuple recursive expansion','ninefold recursive expansion'];
//exp[-1]='collapse',exp[-2]='view';
exp=['Expand','Recursivly expand','Recursivly expand 2nd time','Recursivly expand 3rd time','Recursivly expand 4th time','Recursivly expand 5th time','Recursivly expand 6th time','Recursivly expand 7th time','Recursivly expand 8th time','Recursivly expand 9th time'];
exp[-1]='Collapse',exp[-2]='view';
let count=1,vt=true,pairb=[],pairl=[],exb=[],di=5,fsl,fsn,fsp,lea,format=1,ps=[];
let far=[for0,for1,for2];
let indentar=[indentmode0,indentmode1,indentmode2];
let mousex,mousey;
let gtkey=3,ltkey=3;
let processing=true;
let indentmode=1;
let indentvisible=1;
let keytcheck=true;
let mousetag,mousetagp=xs;
let fscurrent,fsopening,fsperiod0,fsperiod1,fsending,cofcurrent,cofclass,cardclass;
let fsnumber=1,fsopeningarray,fsperiodarray,fsendingarray;
let cofclasslist=['','zero','successor','regular cardinal','singular cardinal'];
let cardclasslist=['finite cardinal','countable','uncountable','countable cardinal','uncountable cardinal'];
let ulnar=['UL1','UL'];
let markedli;
let prevsmallexp,nextsmallexpn;
let nextl,nextlb=false,mulcounter=1;
let nlevels=2;
let bolevels=2;
let leastr;
let vero=0;
let spn=true;
let subperiodpositionshift=0;
let decompositionintoboosterslevels=0;
let leastuncounable;
let initlargeordinal=bo;
initlargeordinalupdate();
//initlargeordinal='[c[[c[c!!!![c[[c[c!!!!'; resetlist();
//let initlargeordinal=col;
//let initlargeordinal=bb('',col);
seteo(eo);

/*
let st=`let str='';
for(let j=1;j<50;j++)
   str+='[]';
list.innerHTML+=str;`;
eval(st);
*/

/*
//format=0;
let st='[c[[c[c!!!!';
st='[c[[c[[c[c!!!!!!';
st='[[c![[c![c!!!';
st='[[c![[c![[c![[c![[[c!!!!!!!';
st=booster(st);
st=cnf(st); 
st=cnf(JSON.parse(JSON.stringify(st)),true); 
  
list.innerHTML+=(JSON.stringify(st)).toString().replaceAll('!',']').replaceAll('"','');
//list.innerHTML+=convert(st)+'<br/>';
//list.innerHTML+=checkstring(st)+'<br/>';
*/

dis.innerHTML='   '+di+'   ';
decintoboostersl.innerHTML='   '+decompositionintoboosterslevels+'   ';
far[format].style.background='#d0ffd0';
indentar[indentvisible?indentmode:2].style.background='#d0ffd0';
fs(initlargeordinal,'',0);

</script></div></body></html>
